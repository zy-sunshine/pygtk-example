<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>8.3. Common Range Methods</title><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="PyGTK 2.0 Tutorial"><link rel="up" href="ch-RangeWidgets.html" title="Chapter 8. Range Widgets"><link rel="previous" href="sec-ScaleWidgets.html" title="8.2. Scale Widgets"><link rel="next" href="sec-KeyAndMouseBindings.html" title="8.4. Key and Mouse Bindings"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8.3. Common Range Methods</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="sec-ScaleWidgets.html">Prev</a> </td><th width="60%" align="center">Chapter 8. Range Widgets</th><td width="20%" align="right"> <a accesskey="n" href="sec-KeyAndMouseBindings.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-CommonRangeMethods"></a>8.3. Common Range Methods</h2></div></div><div></div></div><p>The <tt class="classname">Range</tt> widget class is fairly
complicated internally, but, like all the "base class" widgets, most of its
complexity is only interesting if you want to hack on it. Also, almost all
of the methods and signals it defines are only really used in writing
derived widgets. There are, however, a few useful methods that will work on
all range widgets.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2785803"></a>8.3.1. Setting the Update Policy</h3></div></div><div></div></div><p>The "update policy" of a range widget defines at what points
during user interaction it will change the value field of its
<tt class="classname">Adjustment</tt> and emit the "value_changed" signal on
this <tt class="classname">Adjustment</tt>. The update policies are:</p><table border="0" width="100%" bgcolor="#FFECCE"><col align="left" valign="top" width="0*"><tbody><tr><td><span class="term"> UPDATE_CONTINUOUS</span></td><td><p>This is the default. The "value_changed" signal is
emitted continuously, i.e., whenever the slider is moved by even the tiniest
amount.</p></td></tr><tr><td><span class="term">UPDATE_DISCONTINUOUS</span></td><td><p>The "value_changed" signal is only emitted once the
slider has stopped moving and the user has released the mouse button.</p></td></tr><tr><td><span class="term">UPDATE_DELAYED</span></td><td><p>The "value_changed" signal is emitted when the user
releases the mouse button, or if the slider stops moving for a short period
of time.</p></td></tr></tbody></table><p>The update policy of a range widget can be set by passing it
to this method:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
  range.set_update_policy(<b class="parameter"><tt>policy</tt></b>)
</pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2785875"></a>8.3.2. Getting and Setting Adjustments</h3></div></div><div></div></div><p>Getting and setting the adjustment for a range widget "on the
fly" is done, predictably, with:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
  adjustment = range.get_adjustment()

  range.set_adjustment(<b class="parameter"><tt>adjustment</tt></b>)
</pre></td></tr></table><p>The <tt class="methodname">get_adjustment</tt>() method returns a
reference to the <i class="parameter"><tt>adjustment</tt></i> to which range is
connected.</p><p>The <tt class="methodname">set_adjustment</tt>() method does
absolutely nothing if you pass it the <i class="parameter"><tt>adjustment</tt></i> that
<i class="parameter"><tt>range</tt></i> is already using, regardless of whether you
changed any of its fields or not. If you pass it a new
<tt class="classname">Adjustment</tt>, it will unreference the old one if it
exists (possibly destroying it), connect the appropriate signals to the new
one, and will recalculate the size and/or position of the slider and redraw
if necessary. As mentioned in the section on adjustments, if you wish to
reuse the same <tt class="classname">Adjustment</tt>, when you modify its values
directly, you should emit the "changed" signal on it, like this:</p><table border="0" bgcolor="#E0E0E0" width="100%"><tr><td><pre class="programlisting">
  adjustment.emit("changed")
</pre></td></tr></table></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sec-ScaleWidgets.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch-RangeWidgets.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sec-KeyAndMouseBindings.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.2. Scale Widgets </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 8.4. Key and Mouse Bindings</td></tr></table></div></body></html>
